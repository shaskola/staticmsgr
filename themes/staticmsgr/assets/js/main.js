// Log site initialization
console.log('%cüöÄ MascotMessenger Initializing...', 'color: #E91E63; font-size: 16px; font-weight: bold;');

// Log environment info
console.log('%cüìä Environment Info:', 'color: #2196F3; font-weight: bold;', {
    url: window.location.href,
    path: window.location.pathname,
    hugo: 'This site was generated by Hugo'
});

// API Configuration
const API_CONFIG = {
    baseUrl: 'https://showcase.newhideaway.com',
    tableId: '787',
    endpoints: {
        messages: '/api/database/rows/table/787/',
        characters: '/api/database/rows/table/788/'
    }
};

console.log('%cüîå API Configuration:', 'color: #673AB7; font-weight: bold;', API_CONFIG);

// Function to log API responses
async function fetchWithLogging(url, options = {}) {
    console.log('%cüì° API Request:', 'color: #00BCD4; font-weight: bold;', {
        url,
        method: options.method || 'GET',
        headers: options.headers,
        timestamp: new Date().toISOString()
    });

    try {
        const startTime = performance.now();
        const response = await fetch(url, options);
        const endTime = performance.now();
        
        // Log response headers
        const headers = {};
        response.headers.forEach((value, key) => {
            headers[key] = value;
        });
        
        console.log('%cüîç Response Headers:', 'color: #9C27B0; font-weight: bold;', headers);
        
        // Try to get response data
        let data;
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            data = await response.json();
        } else {
            const text = await response.text();
            console.warn('%c‚ö†Ô∏è Non-JSON Response:', 'color: #FF9800; font-weight: bold;', text);
            throw new Error('Unexpected response format');
        }
        
        console.log('%c‚úÖ API Response:', 'color: #4CAF50; font-weight: bold;', {
            status: response.status,
            statusText: response.statusText,
            timeMs: Math.round(endTime - startTime),
            dataSize: JSON.stringify(data).length,
            data: data
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        return data;
    } catch (error) {
        console.error('%c‚ùå API Error:', 'color: #f44336; font-weight: bold;', {
            url,
            error: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
        });
        
        // Additional error context
        if (error instanceof TypeError) {
            console.error('%cüîç Network Error Details:', 'color: #f44336; font-weight: bold;', {
                type: 'Network Error',
                possible_causes: [
                    'CORS issues',
                    'Network connectivity',
                    'Invalid URL',
                    'Server unreachable'
                ]
            });
        }
        
        throw error;
    }
}

// Function to log message data
function logMessageData(message) {
    if (!message) return;
    
    const messageData = {
        title: message.querySelector('h1')?.textContent,
        type: message.dataset.type,
        date: message.dataset.date,
        username: message.dataset.username,
        hasAvatar: !!message.querySelector('.avatar'),
        hasImage: !!message.querySelector('.message-image'),
        hasButtons: !!message.querySelector('.message-buttons'),
        attributes: Object.assign({}, message.dataset),
        classes: Array.from(message.classList),
        html: message.innerHTML.slice(0, 200) + '...' // First 200 chars
    };
    
    console.log('%cüìù Message Data:', 'color: #4CAF50; font-weight: bold;', messageData);
    
    // Log any validation issues
    const validationIssues = [];
    if (!messageData.date) validationIssues.push('Missing date');
    if (!messageData.type) validationIssues.push('Missing type');
    if (!messageData.title) validationIssues.push('Missing title');
    
    if (validationIssues.length > 0) {
        console.warn('%c‚ö†Ô∏è Message Validation Issues:', 'color: #FF9800; font-weight: bold;', {
            messageId: messageData.title,
            issues: validationIssues
        });
    }
}

// Log all messages on the page
document.addEventListener('DOMContentLoaded', async () => {
    console.log('%cüåê Page Loaded', 'color: #9C27B0; font-weight: bold;');
    
    // Log page info
    console.log('%cüìÑ Page Info:', 'color: #FF9800; font-weight: bold;', {
        title: document.title,
        url: window.location.href,
        readyState: document.readyState,
        timestamp: new Date().toISOString()
    });
    
    // Try to fetch messages
    try {
        const messagesUrl = `${API_CONFIG.baseUrl}${API_CONFIG.endpoints.messages}?user_field_names=true`;
        const messages = await fetchWithLogging(messagesUrl);
        console.log('%cüì® API Messages:', 'color: #607D8B; font-weight: bold;', {
            count: messages?.length || 0,
            firstMessage: messages?.[0],
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('%c‚ùå Failed to fetch messages:', 'color: #f44336; font-weight: bold;', {
            error: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
        });
    }
    
    // Find and log DOM messages
    const domMessages = document.querySelectorAll('.message');
    console.log('%cüì® Found DOM Messages:', 'color: #607D8B; font-weight: bold;', {
        count: domMessages.length,
        elements: Array.from(domMessages).map(el => ({
            id: el.id,
            classes: Array.from(el.classList),
            type: el.dataset.type
        }))
    });
    
    domMessages.forEach((message, index) => {
        console.log(`%cüìé Message ${index + 1}:`, 'color: #795548; font-weight: bold;');
        logMessageData(message);
    });
});

// Enhanced error logging
window.onerror = function(msg, url, lineNo, columnNo, error) {
    console.error('%c‚ùå JavaScript Error:', 'color: #f44336; font-weight: bold;', {
        message: msg,
        url: url,
        line: lineNo,
        column: columnNo,
        stack: error?.stack,
        timestamp: new Date().toISOString(),
        error: error?.toString()
    });
    return false;
};

// Enhanced resource error logging
window.addEventListener('error', function(e) {
    if (e.target.tagName) {
        console.error('%cüö´ Resource Error:', 'color: #f44336; font-weight: bold;', {
            element: e.target.tagName.toLowerCase(),
            src: e.target.src || e.target.href,
            type: e.type,
            timestamp: new Date().toISOString(),
            elementHtml: e.target.outerHTML
        });
    }
}, true);

// Enhanced promise rejection logging
window.addEventListener('unhandledrejection', function(e) {
    console.error('%cüí• Unhandled Promise Rejection:', 'color: #f44336; font-weight: bold;', {
        reason: e.reason,
        stack: e.reason?.stack,
        timestamp: new Date().toISOString(),
        type: e.reason?.constructor?.name
    });
});
